<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
 </head>
 <body>
  <h1>
   <b>
    Lattice Methods for Path-dependent Options
   </b>
  </h1>
  <p block-type="TextInlineMath">
   Path-dependent options are options whose payoffs depend on some specific function
   <math display="inline">
    F
   </math>
   of the entire trajectory of the asset price
   <math display="inline">
    F_t = F(t, (S_u)_{u \le t})
   </math>
   . The most well-known examples are the lookback options and Asian options. In a lookback option, the payoff function is dependent on the realized maximum or minimum price of the asset over a certain period within the life of the option. The Asian options are also called
   <i>
    average options
   </i>
   since the payoff depends on a prespecified form of averaging of the asset price over a certain period. Consider an arithmetic average Asian option that is issued at time
   <math display="inline">
    0
   </math>
   and expiring at
   <math display="inline">
    T &gt; 0
   </math>
   , its terminal payoff is dependent on the arithmetic average
   <math display="inline">
    A_T
   </math>
   of the asset price process
   <math display="inline">
    S_t
   </math>
   over period [0, T]. The running average value
   <math display="inline">
    A_t
   </math>
   is defined as
  </p>
  <p block-type="Equation">
   <math display="block">
    A_t = \frac{1}{t} \int_0^t S_u \, \mathrm{d}u \tag{1}
   </math>
  </p>
  <p block-type="TextInlineMath">
   with
   <math display="inline">
    A_0 = S_0
   </math>
   . We are interested in the correlated evolution of the path function with the asset price process. In the above example of arithmetic averaging, the law of evolution of
   <math display="inline">
    A_t
   </math>
   is given as
  </p>
  <p block-type="Equation">
   <math display="block">
    dA_t = \frac{1}{t}(S_t - A_t) dt
   </math>
   (2)
  </p>
  <p block-type="TextInlineMath">
   A variant of the lattice tree methods (binomial/trinomial methods), called the
   <i>
    forward shooting
   </i>
   grid (FSG) approach, has been successfully applied to price a wide range of strong path-dependent options, such as the lookback options, Asian options, convertible bonds with reset feature and Parisian feature. reset strike feature in shout options, and so on. The FSG approach is characterized by augmenting an auxiliary state vector at each node in the usual lattice tree, which serves to capture the path-dependent feature of the option. Under the discrete setting of lattice tree calculations, let
   <math display="inline">
    G
   </math>
   denote the function that describes the correlated evolution of
   <math display="inline">
    F
   </math>
   with
   <math display="inline">
    S
   </math>
   over the time step
   <math display="inline">
    \Delta t
   </math>
   , which can be expressed as
  </p>
  <p block-type="Equation">
   <math display="block">
    F_{t+\Delta t} = G(t, F_t, S_{t+\Delta t}) \tag{3}
   </math>
  </p>
  <p block-type="Text">
   For example, let
   <math display="inline">
    A^n
   </math>
   denote the discretely observed arithmetic average defined as
  </p>
  <p block-type="Equation">
   <math display="block">
    A^n = \frac{\sum_{i=0}^n S^i}{n+1} \tag{4}
   </math>
  </p>
  <p block-type="TextInlineMath">
   where
   <math display="inline">
    S^i
   </math>
   is the observed asset price at time
   <math display="inline">
    t_i
   </math>
   ,
   <math display="inline">
    i =
   </math>
   <math display="inline">
    0, 1, \ldots, n
   </math>
   . The correlated evolution of
   <math display="inline">
    A^{n+1}
   </math>
   with
   <math display="inline">
    S^{n+1}
   </math>
   is seen to be
  </p>
  <p block-type="Equation">
   <math display="block">
    A^{n+1} = A^n + \frac{S^{n+1} - A^n}{n+2} \tag{5}
   </math>
  </p>
  <p block-type="TextInlineMath">
   Another example is provided by the correlated evolution of the realized maximum price
   <math display="inline">
    M_t
   </math>
   and its underlying asset price process
   <math display="inline">
    S_t
   </math>
   . Recall
   <math display="inline">
    M_t =
   </math>
   <math display="inline">
    \max S_u
   </math>
   so that
   <math display="inline">
    0 \leq u \leq t
   </math>
  </p>
  <p block-type="Equation">
   <math display="block">
    M_{t+\Delta t} = \max(M_t, S_{t+\Delta t}) \tag{6}
   </math>
  </p>
  <p block-type="Text">
   In the construction of the auxiliary state vector, it is necessary to know the number of possible values that can be taken by the path-dependent state variable. For the lookback feature, the realized maximum asset price is necessarily one of the values taken by the asset price in the lattice tree. However, the number of possible values for the arithmetic average grows exponentially with the number of time steps. To circumvent the problem of dealing with exceedingly large number of nodal values, the state vector is constructed such that it contains a set of predetermined nodal values that cover the range of possible values of arithmetic averaging. Since the realized arithmetic average does not fall on these nodal values in general, we apply interpolation between the nodal values as an approximation.
  </p>
  <p block-type="Text">
   The FSG approach is pioneered by Hull and White [4] and Ritchken et al. [10] for pricing American and European style Asian and lookback options. Theoretical studies on the construction and convergence analysis of the FSG schemes are presented by Barraquand and Pudet [1], Forsyth et al. [3], and Jiang and Dai [5]. A list of various applications of the FSG approach in lattice tree algorithms for pricing strongly path-dependent options/derivative products is given as follows:
  </p>
  <p block-type="ListGroup">
   <ul>
    <li block-type="ListItem">
     options whose underlying asset price follows various kinds of GARCH processes [11];
    </li>
    <li block-type="ListItem">
     path-dependent interest rate claims [9];
     <math display="inline">
      \bullet
     </math>
    </li>
    <li block-type="ListItem">
     Parisian options, alpha-quantile options, and strike . reset options
     <math display="inline">
      [6]
     </math>
     ;
    </li>
   </ul>
  </p>
  <h4>
   2
   <b>
    Lattice Methods for Path-dependent Options
   </b>
  </h4>
  <p block-type="ListGroup">
   <ul>
    <li block-type="ListItem">
     soft call requirement in convertible bonds [7]; Ù 
    </li>
    <li block-type="ListItem">
     target redemption notes [2]; and
    </li>
    <li block-type="ListItem">
     employee stock options with repricing features [8]
    </li>
   </ul>
  </p>
  <p block-type="Text">
   In this article, we illustrate the application of the FSG lattice tree algorithms for pricing options with path-dependent lookback and Asian features, convertible bonds with the soft call requirement (Parisian feature), and call options with the strike reset feature.
  </p>
  <h3>
   <b>
    Lookback Options
   </b>
  </h3>
  <p block-type="TextInlineMath">
   Let the risk neutral probabilities of upward, zero, and downward jump in a trinomial tree be represented by
   <math display="inline">
    p_u
   </math>
   ,
   <math display="inline">
    p_0
   </math>
   , and
   <math display="inline">
    p_d
   </math>
   , respectively. In the FSG approach for capturing the path dependence of the discrete asset price process, we append an augmented state vector at each node in the trinomial tree and determine the appropriate grid function that models the discrete correlated evolution of the path dependence. Let
   <math display="inline">
    V_{i,k}^n
   </math>
   denote the numerical option value of the path-dependent option at the
   <math display="inline">
    n
   </math>
   th-time level and
   <math display="inline">
    i
   </math>
   upward jumps from the initial asset value
   <math display="inline">
    S_0
   </math>
   . Here, k denotes the numbering index for the values assumed by the augmented state vector at the
   <math display="inline">
    (n, j)
   </math>
   th node in the trinomial tree. Let u and
   <math display="inline">
    d
   </math>
   denote the proportional upward and downward jump of the asset price over one time step
   <math display="inline">
    \Delta t
   </math>
   , with
   <math display="inline">
    ud = 1
   </math>
   . Let
   <math display="inline">
    g(k, j)
   </math>
   denote the grid function that characterizes the discrete correlated evolution of the path-dependent state variable
   <math display="inline">
    F_t
   </math>
   and asset price process
   <math display="inline">
    S_t
   </math>
   . When applied to the trinomial tree calculations, the FSG scheme takes the following form:
  </p>
  <p block-type="Equation">
   <math display="block">
    V_{j,k}^{n} = e^{-r\Delta t} \left[ p_u V_{j+1,g(k,j+1)}^{n+1} + p_0 V_{j,g(k,j)}^{n+1} + p_d V_{j-1,g(k,j-1)}^{n+1} \right]
   </math>
   (7)
  </p>
  <p block-type="Text">
   where
   <math display="inline">
    e^{-r\Delta t}
   </math>
   denotes the discount factor over one time step (Figure 1).
  </p>
  <p block-type="TextInlineMath">
   We consider the floating strike lookback option whose terminal payoff depends on the realized maximum of the asset price, namely,
   <math display="inline">
    V(S_T, M_T, T) =
   </math>
   <math display="inline">
    M_T - S_T
   </math>
   . The corresponding discrete analogy of the correlated evolution of
   <math display="inline">
    M_t
   </math>
   and
   <math display="inline">
    S_t
   </math>
   is given by the following grid function (equation 6):
  </p>
  <p block-type="Equation">
   <math display="block">
    g(k, j) = \max(k, j) \tag{8}
   </math>
  </p>
  <p>
   <img src="_page_1_Figure_11.jpeg"/>
  </p>
  <p>
   Figure 1 The discrete correlated evolution of the pathdependent state variable
   <math display="inline">
    F_t
   </math>
   and asset price process
   <math display="inline">
    S_t
   </math>
   is characterized by the grid function
   <math display="inline">
    g(k, j)
   </math>
  </p>
  <p block-type="Text">
   As in usual trinomial calculations, we apply the backward induction procedure, starting with the lattice nodes at maturity. Suppose that there are a total of
   <math display="inline">
    N
   </math>
   time steps in the trinomial tree so that the maximum value of the discrete asset price process is
   <math display="inline">
    S_0 u^N
   </math>
   , corresponding to N successive jumps from the initial value
   <math display="inline">
    S_0
   </math>
   . The possible range for realized maximum asset price would be
   <math display="inline">
    \{S_0, S_0u, \ldots, S_0u^N\}
   </math>
   . When these possible values of the path-dependent state variable are indexed by
   <math display="inline">
    k
   </math>
   , then
   <math display="inline">
    k
   </math>
   assumes values from
   <math display="inline">
    0, 1, \ldots
   </math>
   , to N. The terminal option value at the
   <math display="inline">
    (N, j)
   </math>
   th node and kth value in the state vector is given as
  </p>
  <p block-type="Equation">
   <math display="block">
    V_{j,k}^{N} = S_{0}u^{k} - S_{0}u^{j},
   </math>
   <br/>
   <math display="block">
    j = -N, -N + 1, ..., N \text{ and}
   </math>
   <br/>
   <math display="block">
    k = \max(j, 0), \max(j, 0) + 1, ..., N \quad (9)
   </math>
  </p>
  <p block-type="Text">
   Applying backward induction over one time step from expiry, the option values at the
   <math display="inline">
    (N-1)
   </math>
   th time level are given as
  </p>
  <p block-type="Equation">
   <math display="block">
    V_{j,k}^{N-1} = e^{-r\Delta t} \left[ p_u V_{j+1,\max(k,j+1)}^N + p_0 V_{j,\max(k,j)}^N + p_d V_{j-1,\max(k,j-1)}^N \right]
   </math>
   <br/>
   <math display="block">
    j = -N + 1, -N + 2, \dots, N - 1,
   </math>
   <br/>
   <math display="block">
    k = \max(j, 0) + 1, \dots, N - 1 \tag{10}
   </math>
  </p>
  <p block-type="Text" class="has-continuation">
   where the terminal option values are defined in equation (9). The backward induction procedure is then repeated to obtain numerical option values at the lattice nodes at earlier time levels. Note that the range
  </p>
  <p block-type="Text">
   of the possible values assumed by the path-dependent state variable narrows as we proceed backward in a stepwise manner until we reach the tip of the trinomial tree.
  </p>
  <h4>
   <b>
    Asian Options
   </b>
  </h4>
  <p block-type="Text">
   Recall that the asset price
   <math display="inline">
    S_i^n
   </math>
   at the
   <math display="inline">
    (n, j)
   </math>
   th node in the trinomial tree is given as
  </p>
  <p block-type="Equation">
   <math display="block">
    S_j^n = S_0 u^j = S_0 e^{j\Delta W}, \quad j = -n, -n+1, \dots, n
   </math>
   (11)
  </p>
  <p block-type="TextInlineMath">
   where
   <math display="inline">
    u = e^{\Delta W}
   </math>
   with
   <math display="inline">
    \Delta W = \sigma \sqrt{\Delta t}
   </math>
   . Here,
   <math display="inline">
    \sigma
   </math>
   is the volatility of the asset price. The average asset price at the
   <i>
    n
   </i>
   th time level must lie between
   <math display="inline">
    \{S_0u^{-n}, S_0u^n\}
   </math>
   . We take
   <math display="inline">
    \rho &lt; 1
   </math>
   and let
   <math display="inline">
    \Delta Y = \rho \Delta W
   </math>
   . Let floor(x) denote the largest integer less than or equal to
   <math display="inline">
    x
   </math>
   and
   <math display="inline">
    \text{ceil}(x) = \text{floor}(x) + 1
   </math>
   . We set the possible values taken by the average asset price to be
  </p>
  <p block-type="Equation">
   <math display="block">
    A_k^n = S_0 e^{k\Delta Y}, \quad k = \text{floor}\left(-\frac{n}{\rho}\right), \dots, \text{ceil}\left(\frac{n}{p}\right) \tag{12}
   </math>
  </p>
  <p block-type="TextInlineMath">
   The earlier FSG schemes choose
   <math display="inline">
    \rho
   </math>
   to be a sufficiently small number that is independent of
   <math display="inline">
    \Delta t
   </math>
   . The larger the value chosen for
   <math display="inline">
    1/\rho
   </math>
   , the finer the quantification of the average asset price. In view of numerical convergence of the FSG schemes, Forsyth
   <i>
    et al.
   </i>
   [3] propose to choose
   <math display="inline">
    \rho
   </math>
   to depend on
   <math display="inline">
    \sqrt{\Delta t}
   </math>
   (say,
   <math display="inline">
    \rho = \lambda \sqrt{\Delta t}
   </math>
   , where
   <math display="inline">
    \lambda
   </math>
   is independent of
   <math display="inline">
    \Delta t
   </math>
   ), though this would result in an excessive amount of computation in actual implementation. Further details on numerical convergence of various versions of the FSG schemes are presented later.
  </p>
  <p block-type="TextInlineMath">
   Suppose that the average is
   <math display="inline">
    A_k^n
   </math>
   and the asset price moves upward from
   <math display="inline">
    S_j^n
   </math>
   to
   <math display="inline">
    S_{j+1}^{n+1}
   </math>
   , then the new average is given as (equation
   <math display="inline">
    5
   </math>
   )
  </p>
  <p block-type="Equation">
   <math display="block">
    A_{k^{+}(j)}^{n+1} = A_k^n + \frac{S_{j+1}^{n+1} - A_k^n}{n+2}
   </math>
   (13)
  </p>
  <p block-type="TextInlineMath">
   Next, we set
   <math display="inline">
    A_{k^+(j)}^{n+1}
   </math>
   to be
   <math display="inline">
    S_0e^{k^+(j)\Delta Y}
   </math>
   for some value
   <math display="inline">
    k^+(i)
   </math>
   , that is,
  </p>
  <p block-type="Equation">
   <math display="block">
    k^{+}(j) = \frac{\ln A_{k^{+}(j)}^{n+1}/S_0}{\Delta Y} \tag{14}
   </math>
  </p>
  <p block-type="TextInlineMath" class="has-continuation">
   Note that
   <math display="inline">
    k^+(j)
   </math>
   is not an integer in general, so
   <math display="inline">
    A_{k^+(i)}^{n+1}
   </math>
   does not fall onto one of the preset values for the average. Recall that floor(
   <math display="inline">
    k^+(j)
   </math>
   ) is
  </p>
  <p block-type="TextInlineMath">
   the largest integer less than or equal to
   <math display="inline">
    k^+(i)
   </math>
   and
   <math display="inline">
    \text{ceil}(k^+(j)) = \text{floor}(k^+(j)) + 1
   </math>
   . By the above construction,
   <math display="inline">
    A_{\text{floor}(k^+(j))}^{n+1}
   </math>
   and
   <math display="inline">
    A_{\text{ceil}(k^+(j))}^{n+1}
   </math>
   now fall onto the set of preset values. Similarly, we define
  </p>
  <p block-type="Equation">
   <math display="block">
    A_{k^{-}(j)}^{n+1} = A_k^n + \frac{S_{j-1}^{n+1} - A_k^n}{n+2}
   </math>
   <br/>
   <math display="block">
    A_{k^{0}(j)}^{n+1} = A_k^n + \frac{S_j^{n+1} - A_k^n}{n+2}
   </math>
   (15)
  </p>
  <p block-type="TextInlineMath">
   corresponding to the new average at the
   <math display="inline">
    (n +
   </math>
   1)th time level when the asset price experiences a downward jump and zero jump, respectively. In addition, floor
   <math display="inline">
    (k^-(j))
   </math>
   , ceil
   <math display="inline">
    (k^-(j))
   </math>
   , floor
   <math display="inline">
    (k^0(j))
   </math>
   , and
   <math display="inline">
    \text{ceil}(k^0(j))
   </math>
   are obtained in a similar manner.
  </p>
  <p block-type="TextInlineMath">
   Let
   <math display="inline">
    V_{i,k^+(i)}^n
   </math>
   denote the Asian option value at node
   <math display="inline">
    (n, j)
   </math>
   with the averaging state variable
   <math display="inline">
    A_t
   </math>
   assuming the value
   <math display="inline">
    A_{k^+(j)}^n
   </math>
   , and assuming similar notation for
   <math display="inline">
    V_{j,\text{floor}(k^+(j))}^n
   </math>
   , and so on. In the lattice tree calculations, numerical option values for
   <math display="inline">
    V_{i k}^{n}
   </math>
   are obtained only for the case when
   <math display="inline">
    k
   </math>
   is an integer. Since
   <math display="inline">
    k^+(j)
   </math>
   assumes a noninteger value in general,
   <math display="inline">
    V_{i,k^+(j)}^n
   </math>
   is approximated through interpolation using option values at the neighboring nodes. Suppose that linear interpolation is adopted; we approximate
   <math display="inline">
    V_{i,k^+(i)}^n
   </math>
   by the following interpolation formula:
  </p>
  <p block-type="Equation">
   <math display="block">
    V_{j,k^{+}(j)}^{n} = \epsilon_{j,k}^{+} V_{j,\text{ceil}(k^{+}(j))}^{n} + (1 - \epsilon_{j,k}^{+}) V_{j,\text{floor}(k^{+}(j))}^{n}
   </math>
   (16)
  </p>
  <p block-type="Text">
   where
  </p>
  <p block-type="Equation">
   <math display="block">
    \epsilon_{j,k}^{+} = \frac{\ln A_{k^{+}(j)}^{n} - \ln A_{\text{floor}(k^{+}(j))}^{n}}{\Delta Y} \tag{17}
   </math>
  </p>
  <p block-type="Text">
   The FSG algorithm with linear interpolation for pricing an Asian option can be formulated as follows (Figure
   <math display="inline">
    2
   </math>
   ):
  </p>
  <p block-type="Equation">
   <math display="block">
    V_{j,k}^{n} = e^{-r\Delta t} \left( p_{u} V_{j,k^{+}(j)}^{n+1} + p_{0} V_{j,k^{0}(j)}^{n+1} + p_{d} V_{j,k^{-}(j)}^{n+1} \right)
   </math>
   <br/>
   <math display="block">
    = e^{-r\Delta t} \left\{ p_{u} \left[ \epsilon_{j,k}^{+} V_{j,\text{ceil}(k^{+}(j))}^{n+1} + (1 - \epsilon_{j,k}^{+}) V_{j,\text{floor}(k^{+}(j))}^{n+1} \right] + p_{0} \left[ \epsilon_{j,k}^{0} V_{j,\text{ceil}(k^{0}(j))}^{n+1} + (1 - \epsilon_{j,k}^{0}) V_{j,\text{floor}(k^{0}(j))}^{n+1} \right] + p_{d} \left[ \epsilon_{j,k}^{-} V_{j,\text{ceil}(k^{-}(j))}^{n+1} + (1 - \epsilon_{j,k}^{-}) V_{j,\text{floor}(k^{-}(j))}^{n+1} \right] \right\}
   </math>
   (18)
  </p>
  <p>
   <img src="_page_3_Figure_1.jpeg"/>
  </p>
  <p>
   <b>
    Figure 2
   </b>
   The average value
   <math display="inline">
    A_k^n
   </math>
   at the
   <i>
    n
   </i>
   th time step changes to
   <math display="inline">
    A_{k^+(i)}^{n+1}
   </math>
   at the
   <math display="inline">
    (n+1)
   </math>
   th time step upon an upward move of the asset price from
   <math display="inline">
    S_j^n
   </math>
   to
   <math display="inline">
    S_{j+1}^{n+1}
   </math>
   . The option value at node
   <math display="inline">
    (n + 1, j + 1)
   </math>
   with asset price average
   <math display="inline">
    A_{k+(j)}^n
   </math>
   is approximated by linear interpolation between the option values with asset price average
   <math display="inline">
    A_{\text{floor}(k^+(j))}^{n+1}
   </math>
   and
   <math display="inline">
    A_{\text{ceil}(k^+(j))}^{n+1}
   </math>
  </p>
  <h4>
   Numerical Convergence of FSG Schemes
  </h4>
  <p block-type="TextInlineMath">
   Besides linear interpolation between two neighboring nodal values, other forms of interpolation can be adopted (say, quadratic interpolation between 3 neighboring nodal values or nearest node point interpolation). Forsyth et al. [3] remark that the FSG algorithm using
   <math display="inline">
    \rho
   </math>
   that is independent of
   <math display="inline">
    \Delta t
   </math>
   and the nearest node point interpolation may exhibit large errors as the number of time steps increases. They also prove that this choice of
   <math display="inline">
    \rho
   </math>
   in the FSG algorithm together with linear interpolation converges to the correct solution plus a constant error term. Unfortunately, the error term cannot be reduced by decreasing the size of the time step. To ensure convergence of the FSG calculations to the true Asian option price, they propose to use
   <math display="inline">
    \rho
   </math>
   that depends on
   <math display="inline">
    \sqrt{\Delta t}
   </math>
   , though this would lead to a large number of nodes in the averaging direction. More precisely, if
   <math display="inline">
    \rho
   </math>
   is independent of
   <math display="inline">
    \sqrt{\Delta t}
   </math>
   , then the complexity of the FSG method is
   <math display="inline">
    O(n^3)
   </math>
   , but convergence cannot be guaranteed. If we set
   <math display="inline">
    \rho = \lambda \sqrt{\Delta t}
   </math>
   , which guarantees convergence, then the complexity becomes
   <math display="inline">
    O(n^{7/2})
   </math>
   .
  </p>
  <h2>
   Soft Call Requirement in Callable
   <b>
    Convertible Bonds
   </b>
  </h2>
  <p block-type="Text" class="has-continuation">
   Most convertible bonds contain the call provision that allows the issuer to have the flexibility to manage the debt-equity ratio in the company's capital structure. To protect the conversion premium paid upfront by the bondholders to be called away too soon, the bond indenture commonly contains the hard call protection
  </p>
  <p block-type="Text">
   clause that prevents the issuer from initiating a call during the early life of the convertible bond. In addition, the soft call clause further requires the stock price to stay above the trigger price (typically 30% higher than the conversion price) for a consecutive or cumulative period before initiation of issuer's call. The purpose of the soft call clause is to minimize the potential of market manipulation by the issuer.
  </p>
  <p block-type="TextInlineMath">
   The path-dependent feature that models the phenomenon of the asset price staying above some threshold level for a certain period of time is commonly called the
   <i>
    Parisian feature
   </i>
   . Let
   <math display="inline">
    B
   </math>
   denote the trigger price and the "Parisian" clock starts counting (cumulatively or consecutively) when the asset price stays above
   <math display="inline">
    B
   </math>
   . In the discrete trinomial evolution of the asset price, we construct the grid function
   <math display="inline">
    g_{\text{cum}}(k, j)
   </math>
   that models the correlated evolution of the discrete asset price process and the cumulative counting of the number of time steps that
   <math display="inline">
    S_i \geq B
   </math>
   . Given that
   <math display="inline">
    k
   </math>
   is the cumulative counting of the number of time steps that the asset price has been staying above B, the index k increases its value by 1 when
   <math display="inline">
    S_i \geq B
   </math>
   . Then we have
  </p>
  <p block-type="Equation">
   <math display="block">
    g_{\text{cum}}(k, j) = k + \mathbf{1}_{\{S_j \ge B\}} \tag{19}
   </math>
  </p>
  <p block-type="TextInlineMath">
   where
   <math display="inline">
    \mathbf{1}_{\{S_i \geq B\}}
   </math>
   denotes the indicator function associated with the event
   <math display="inline">
    \{S_i \geq B\}
   </math>
   . In a similar manner, the grid function
   <math display="inline">
    g_{\text{con}}(k, j)
   </math>
   that models the consecutive counting of the number of time steps that
   <math display="inline">
    S_i \geq B
   </math>
   is defined as
  </p>
  <p block-type="Equation">
   <math display="block">
    g_{\text{con}}(k,j) = (k+1)\mathbf{1}_{\{S_j \ge B\}} \tag{20}
   </math>
  </p>
  <p block-type="Text">
   Using the FSG approach, the path dependence of the soft call requirement can be easily incorporated into the pricing algorithm for a convertible bond with call provision [7]. Suppose that the number of cumulative time steps required for activation of the call provision is
   <math display="inline">
    K
   </math>
   ; then the dynamic programming procedure that enforces the interaction of the game option of holder's optimal conversion and issuer's optimal call is applied at a given lattice grid only when the condition
   <math display="inline">
    g_{\text{cum}}(k, j) \geq K
   </math>
   is satisfied.
  </p>
  <h1>
   <b>
    Call Options with Strike Reset Feature
   </b>
  </h1>
  <p block-type="TextInlineMath">
   Consider a call option with strike reset feature where the option's strike price is reset to the prevailing asset price on a preset reset date if the option is out of the money on that date. Let
   <math display="inline">
    t_i
   </math>
   ,
   <math display="inline">
    i = 1, 2, \ldots, M
   </math>
   , denote
  </p>
  <p block-type="TextInlineMath">
   the reset dates and
   <math display="inline">
    X_i
   </math>
   denote the strike price specified on
   <math display="inline">
    t_i
   </math>
   based on the above reset rule. Write
   <math display="inline">
    X_0
   </math>
   as the strike price set at initiation; then,
   <math display="inline">
    X_i
   </math>
   is given as
  </p>
  <p block-type="Equation">
   <math display="block">
    X_i = \min(X_0, X_{i-1}, S_{t_i}) \tag{21}
   </math>
  </p>
  <p block-type="Text">
   where
   <math display="inline">
    S_{t_i}
   </math>
   is the prevailing asset price at reset date
   <math display="inline">
    t_i
   </math>
   . Note that the strike price at expiry of this call option is not fixed since its value depends on the realization of the asset price at the reset dates. When we apply the backward induction procedure in the trinomial calculations, we encounter the difficulty in defining the terminal payoff since the strike price is not yet known. These difficulties can be resolved easily using the FSG approach by tracking the evolution of the asset price and the reset strike price through an appropriate choice of the grid function [6].
  </p>
  <p block-type="TextInlineMath">
   Recall that
   <math display="inline">
    S_0
   </math>
   is the asset price at the tip of the trinomial tree and the asset price after
   <math display="inline">
    j
   </math>
   net upward jumps is
   <math display="inline">
    S_0 u^j
   </math>
   . In our notation, the index k is used as the one-to-one correspondence to the asset price level
   <math display="inline">
    S_0u^k
   </math>
   . Say, suppose that the original strike price
   <math display="inline">
    X_0
   </math>
   corresponds to the index
   <math display="inline">
    k_0
   </math>
   , this would mean
   <math display="inline">
    X_0 =
   </math>
   <math display="inline">
    S_0 u^{k_0}
   </math>
   . For convenience, we may choose the proportional jump parameter
   <math display="inline">
    u
   </math>
   such that
   <math display="inline">
    k_0
   </math>
   is an integer. In terms of these indexes, the grid function that models the correlated evolution between the reset strike price and asset price is given as (see equation
   <math display="inline">
    21
   </math>
   )
  </p>
  <p block-type="Equation">
   <math display="block">
    g_{\text{reset}}(k, j) = \min(k, j, k_0) \tag{22}
   </math>
  </p>
  <p block-type="Text">
   where
   <math display="inline">
    k
   </math>
   denotes the index that corresponds to the strike price reset in the last reset date and
   <math display="inline">
    j
   </math>
   is the index that corresponds to the prevailing asset price at the reset date.
  </p>
  <p block-type="Text">
   Since the strike price is reset only on a reset date, we perform the usual trinomial calculations for those time levels that do not correspond to a reset date while the augmented state vector of strike prices are adjusted according to the grid function
   <math display="inline">
    g_{reset}(k, j)
   </math>
   for those time levels that correspond to a reset date. The FGS algorithm for pricing the reset call option is given as
  </p>
  <p block-type="Equation">
   <math display="block">
    V_{j,k}^{n} = \begin{cases} p_u V_{j+1,k}^{n+1} + p_0 V_{j,k}^{n+1} + p_d V_{j-1,k}^{n+1} \\ \text{if } (n+1)\Delta t \neq t_i \text{ for some } i \end{cases}
   </math>
   <math display="block">
    p_u V_{j+1,g_{\text{reset}}(k,j+1)}^{n+1} + p_0 V_{j,g_{\text{reset}}(k,j)}^{n+1} \\ + p_d V_{j-1,g_{\text{reset}}(k,j-1)}^{n+1} \\ \text{if } (n+1)\Delta t = t_i \text{ for some } i \end{cases}
   </math>
   (23)
  </p>
  <p block-type="Text">
   Lastly, the payoff values along the terminal nodes at the
   <math display="inline">
    N
   </math>
   th time level in the trinomial tree are given as
  </p>
  <p block-type="Equation">
   <math display="block">
    V_{j,k}^{N} = \max(S_0 u^j - S_0 u^k, 0),
   </math>
   <br/>
   <math display="block">
    j = -N, -N + 1, \dots, N
   </math>
   (24)
  </p>
  <p block-type="Text">
   and k assumes values that are taken by j and
   <math display="inline">
    k_0
   </math>
   .
  </p>
  <h4>
   References
  </h4>
  <p block-type="ListGroup">
   <ul>
    <li block-type="ListItem">
     Barraquand, J. &amp; Pudet, T. (1996). Pricing of Amer-[1] ican path-dependent contingent claims, Mathematical Finance 6, 17-51.
    </li>
    <li block-type="ListItem">
     [2] Chu, C.C. &amp; Kwok, Y.K. (2007). Target redemption note, Journal of Futures Markets 27, 535-554.
    </li>
    <li block-type="ListItem">
     [3] Forsyth, P., Vetzal, K.R. &amp; Zvan, R. (2002). Convergence of numerical methods for valuing pathdependent options using interpolation, Review of Derivatives Research 5, 273-314.
    </li>
    <li block-type="ListItem">
     Hull, J. &amp; White, A. (1993). Efficient procedures for [4] valuing European and American path dependent options,
     <i>
      Journal of Derivatives
     </i>
     <math display="inline">
      1
     </math>
     (Fall), 21â31.
    </li>
    <li block-type="ListItem">
     Jiang, L. &amp; Dai, M. (2004). Convergence of bino-[5] mial tree method for European/American path-dependent options, SIAM Journal of Numerical Analysis 42(3), 1094-1109.
    </li>
    <li block-type="ListItem">
     Kwok, Y.K. &amp; Lau, K.W. (2001). Pricing algorithms [6] for options with exotic path dependence, Journal of Derivatives 9, 28-38.
    </li>
    <li block-type="ListItem">
     Lau, K.W. &amp; Kwok, Y.K. (2004). Anatomy of option [7] features in convertible bonds, Journal of Futures Markets 24(6), 513-532.
    </li>
    <li block-type="ListItem">
     Leung, K.S. &amp; Kwok, Y.K. (2008). Employee stock [8] option valuation with repricing features, Quantitative
     <i>
      Finance
     </i>
     , to appear.
    </li>
    <li block-type="ListItem">
     [9] Ritchken, P. &amp; Chuang, I. (2000). Interest rate option pricing with volatility humps, Review of Derivatives Research 3, 237-262.
    </li>
    <li block-type="ListItem">
     [10] Ritchken, P.L., Sankarasubramanian, L. &amp; Vijh, A.M.
     <math display="inline">
      (1993)
     </math>
     . The valuation of path dependent contract on the average, Management Science 39, 1202-1213.
    </li>
    <li block-type="ListItem">
     <math display="inline">
      [11]
     </math>
     Ritchken, P. &amp; Trevor, R. (1999). Pricing option under generalized GARCH and stochastic volatility processes, Journal of Finance 54(1), 377-402.
    </li>
   </ul>
  </p>
  <h4>
   <b>
    Related Articles
   </b>
  </h4>
  <p block-type="Text">
   Asian Options; Binomial Tree; Convertible Bonds; Lookback Options; Quantization Methods; Tree Methods.
  </p>
  <p block-type="Text">
   YUE-KUEN KWOK
  </p>
 </body>
</html>
